# 认证授权模块 - 用户授权

# 一、用户授权

## 1.1 RABC 介绍

**如何实现授权**？

业界通常基于RBAC实现授权



**RBAC分为两种方式**：

* **基于角色的访问控制**（Role-Based Access Control）

按角色进行授权

> 比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下
>
> ![image-20240129212716152](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129212716152.png)

判断如下图所示

```java
if(主体.hasRole("总经理角色id") ||  主体.hasRole("部门经理角色id")){
    查询工资
}
```



* **基于资源的访问控制**（Resource-Based Access Control）

> 优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改授权代码，**系统可扩展性强**

用户必须具有查询工资权限才可以查询员工工资信息等

访问控制流程如下

![image-20240129212851937](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129212851937.png)

判断如下图所示

```java
if(主体.hasPermission("查询工资权限标识")){
    查询工资
}
```





## 1.2 用户授权准备

本项目在资源服务内部进行授权，**基于资源的授权模式**，因为接口在资源服务，通过在接口处添加授权注解实现授权

### 1.2.1 配置 Nginx 代理



```json
http {
    server_names_hash_bucket_size 64;
    ...
   
   #前端开发服务
  upstream uidevserver{
    server 127.0.0.1:8601 weight=10;
  } 
   server {
        listen       80;
        server_name  teacher.51xuecheng.cn;
        #charset koi8-r;
        ssi on;
        ssi_silent_errors on;
        #access_log  logs/host.access.log  main;
        #location / {
         #   alias   D:/itcast2022/xc_edu3.0/code_1/dist/;
         #   index  index.html index.htm;
        #}
        location / {
            proxy_pass   http://uidevserver;
        }

        location /api/ {
                proxy_pass http://gatewayserver/;
        } 
        
        
   }
```

![image-20240129214820016](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129214820016.png)



### 1.2.2 授权接口测试

在需要授权的接口处使用@PreAuthorize("hasAuthority('权限标识符')")进行控制

下边代码指定/course/list接口需要拥有xc_teachmanager_course_list 权限

> 设置了@PreAuthorize表示执行此方法需要授权，如果当前用户请求接口没有权限则抛出异常
>
> org.springframework.security.access.AccessDeniedException: 不允许访问

```java
@ApiOperation("课程分页查询接口")
@PreAuthorize("hasAuthority('xc_teachmanager_course_list ')")
@PostMapping("/course/list")
public PageResult<CourseBase> list(PageParams pageParams, @RequestBody(required = false) QueryCourseParamsDto queryCourseParamsDto) {
    PageResult<CourseBase> pageResult = courseBaseInfoService.queryCourseBaseList(pageParams, queryCourseParamsDto);
    return pageResult;

}
```

> 注意：需要content模块也继承SpringSecurity，不加的话上面的注解不会生效

验证是否有权限，其实就是验证“authorities”中是否有对应的权限即可

下面的内容后面我们会从数据库查询出来

![image-20240129225823761](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129225823761.png)

### 1.2.3 统一异常处理

可以配置在xuecheng-base工程中

```java
/**
 * 捕捉除了自定义异常以外的其他异常
 */
@ResponseBody
@ExceptionHandler(Exception.class)
@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)//状态码500
public RestErrorResponse exception(Exception e) {
    log.error("【系统异常】{}", e.getMessage(), e);
    e.printStackTrace();
    if (e.getMessage().equals("不允许访问")) {
        return new RestErrorResponse("没有操作此功能的权限");
    }
    return new RestErrorResponse(CommonError.UNKOWN_ERROR.getErrMessage());//执行过程异常，请重试
}
```



## 1.3 授权 数据模型

**xc_user**：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等

**xc_role**：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。

> 为了方便给用户分配权限而创建了一个角色
>
> 角色是根据业务需求来创建的

**xc_user_role**：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有

**xc_menu**:模块表，记录了菜单及菜单下的权限

> 记录了系统所有操作资源的方法

**xc_permission**:角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有

> 其实就是用户表、角色表、菜单表，以及两张关系表

![image-20240129225956584](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129225956584.png)



### 1.3.1 用户表 xc_user

用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等

![image-20240129230642711](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230642711.png)

![image-20240129230701511](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230701511.png)


### 1.3.2 角色表 xc_role

用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有

![image-20240129230710964](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230710964.png)

![image-20240129230720092](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230720092.png)



### 1.3.3 用户角色表 xc_user_role

> 将角色与用户绑定后，其实也就代表着用户有了某些权限

用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有

![image-20240129230732693](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230732693.png)

![image-20240129230742723](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230742723.png)

### 1.3.4 模块表 xc_menu

**为了创建权限更方便，我们创建了一个角色表，角色表中会引用此表的内容**

模块表，记录了菜单及菜单下的权限

> 记录了系统所有操作资源的方法
>
> 下图中的menu_name很容易看出来就是操作方法

![image-20240129230757340](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230757340.png)

code字段就是权限对应的标识

![image-20240129230811269](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230811269.png)



这个menu菜单管理其实不是指的下图左边栏，而是指的右边的权限管理

![image-20240129231857911](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129231857911.png)

### 1.3.5 角色权限表 xc_permission

角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有

角色表和菜单表之前是多对多的关系

> 角色和权限的关系表
>
> 可以看到哪些角色就哪些权限

![image-20240129230825616](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230825616.png)

![image-20240129230838173](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129230838173.png)



### 1.3.6 举例：查询某个用户权限

查询语句

```sql
SELECT * FROM xc_menu WHERE id IN(
    SELECT menu_id FROM xc_permission WHERE role_id IN(
        SELECT role_id FROM xc_user_role WHERE user_id = '49'
    )
)
```

查询结果

![image-20240129232836009](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240129232836009.png)





# 二、数据库查询权限

auth服务模块

![image-20240130000758093](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240130000758093.png)

## 2.1 XcMenuMapper

查询某个用户的权限信息

```java
/**
 * Mapper 接口
 */
public interface XcMenuMapper extends BaseMapper<XcMenu> {
    @Select("SELECT    * FROM xc_menu WHERE id IN (SELECT menu_id FROM xc_permission WHERE role_id IN ( SELECT role_id FROM xc_user_role WHERE user_id = #{userId} ))")
    List<XcMenu> selectPermissionByUserId(@Param("userId") String userId);
}
```





## 2.2 修改 UserServiceImpl

```java
@Component
public class UserServiceImpl implements UserDetailsService {

    @Autowired
    XcMenuMapper xcMenuMapper;

    //注入，将来查询对象
    @Autowired
    XcUserMapper xcUserMapper;

    @Autowired
    ApplicationContext applicationContext;

    /**
     * @param s 传入的请求认证的参数是AuthParamDtoJSON串，此时不再是输入的username（账号）
     */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 1.将传入的JSON转成AuthParamsDto对象
        AuthParamsDto authParamsDto = null;
        try {
            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);
        } catch (Exception e) {
            throw new RuntimeException("请求认证的参数不符合要求");
        }

        // 2.判断登录的类型（认证类型,有password、wx）
        String authType = authParamsDto.getAuthType();
        String beanName = authType + "_authservice";
        // 取出指定的bean
        AuthService authService = applicationContext.getBean(beanName, AuthService.class);

        // 3.调用统一认证方法完成认证
        XcUserExt xcUserExt = authService.execute(authParamsDto);

        // 4.封装XcUserExt为UserDetails类型
        UserDetails userDetails = this.getUserPrincipal(xcUserExt);
        return userDetails;
    }

    /**
     * 将XcUserExt数据封装成UserDetails数据
     *
     * @param xcUserExt 用户id，主键
     * @return com.xuecheng.ucenter.model.po.XcUser 用户信息
     * @description 查询用户信息
     */
    public UserDetails getUserPrincipal(XcUserExt xcUserExt) {
        // 权限信息
        String[] authorities = {"p1"};

        String password = xcUserExt.getPassword();
        //用户权限,如果不加报Cannot pass a null GrantedAuthority collection
        //TODO 根据用户id查询用户权限
        List<XcMenu> xcMenus = xcMenuMapper.selectPermissionByUserId(xcUserExt.getId());
        if (xcMenus.size() > 0) {
            List<String> permissions = new ArrayList<>();
            xcMenus.forEach(m -> {
                // 拿到用户拥有的权限标识符
                permissions.add(m.getCode());
            });
            //permissions 转成数组
            authorities = permissions.toArray(new String[0]);
        }
        xcUserExt.setPassword(""); // 为了安全考虑，专JSON前吧密码做空
        String userString = JSON.toJSONString(xcUserExt);
        UserDetails userDetails = User.withUsername(userString)
                //用户密码
                .password(password)
                //用户权限,暂时先不写
                .authorities(authorities).build();
        return userDetails;
    }

}
```



## 2.3 细粒度授权

### 2.3.1 介绍

**什么是细粒度授权**？

**细粒度授权也叫数据范围授权**

即不同的用户所拥有的操作权限相同，但是能够操作的数据范围是不一样的

> 一个例子：用户A和用户B都是教学机构，他们都拥有“我的课程”权限，但是两个用户所查询到的数据是不一样的





**本项目有哪些细粒度授权**？

* 我的课程，教学机构只允许查询本教学机构下的课程信息。

* 我的选课，学生只允许查询自己所选课。



**如何实现细粒度授权**？

细粒度授权涉及到不同的业务逻辑，通常在service层实现，**根据不同的用户进行校验，根据不同的参数查询不同的数据或操作不同的数据**



### 2.3.2 教学机构细粒度授权

* **教学机构在维护课程时只允许维护本机构的课程**

教学机构细粒度授权过程如下

1）获取当前登录的用户身份

2）得到用户所属教育机构的Id

3）查询该教学机构下的课程信息

最终实现了用户只允许查询自己机构的课程信息

* **根据公司Id查询课程，流程如下**：

1）教学机构用户登录系统，从用户身份中取出所属机构的id

在用户表中设计了company_id字段存储该用户所属的机构id

2）接口层取出当前登录用户的身份，取出机构id

3) 将机构id传入service方法

4) service方法将机构id传入Dao方法，最终查询出本机构的课程信息



**接口信息**

```java
/**
 * 课程分页查询接口
 * @param pageParams           pageNo字段和pageSize字段
 * @param queryCourseParamsDto auditStatus审核状态字段，courseName课程名称字段，publishStatus发布状态字段
 * @return 分页结果
 * @RequestBody(required = false) 含义：不传QueryCourseParamsDto请求体也行
 */
@ApiOperation("课程分页查询接口")
@PreAuthorize("hasAuthority('xc_teachmanager_course_list ')")
@PostMapping("/course/list")
public PageResult<CourseBase> list(PageParams pageParams, @RequestBody(required = false) QueryCourseParamsDto queryCourseParamsDto) {
    SecurityUtil.XcUser user = SecurityUtil.getUser();
    String companyId = user.getCompanyId();
    PageResult<CourseBase> pageResult = courseBaseInfoService.queryCourseBaseList(companyId, pageParams, queryCourseParamsDto);
    return pageResult;

}
```

**Service实现类**

```java
@Override
public PageResult<CourseBase> queryCourseBaseList(Long companyId,PageParams pageParams, QueryCourseParamsDto queryCourseParamsDto) {


    //构建查询条件对象
    LambdaQueryWrapper<CourseBase> queryWrapper = new LambdaQueryWrapper<>();
    //构建查询条件，根据课程名称查询
    queryWrapper.like(StringUtils.isNotEmpty(queryCourseParamsDto.getCourseName()), CourseBase::getName, queryCourseParamsDto.getCourseName());
    //构建查询条件，根据课程审核状态查询
    queryWrapper.eq(StringUtils.isNotEmpty(queryCourseParamsDto.getAuditStatus()), CourseBase::getAuditStatus, queryCourseParamsDto.getAuditStatus());
    //构建查询条件，根据课程发布状态查询
    queryWrapper.eq(StringUtils.isNotEmpty(queryCourseParamsDto.getPublishStatus()), CourseBase::getStatus, queryCourseParamsDto.getPublishStatus());
    //TODO 根据培训机构的id拼装查询条件
    queryWrapper.eq(StringUtils.isNotEmpty(companyId.toString()), CourseBase::getCompanyId, companyId);

    //分页对象
    Page<CourseBase> page = new Page<>(pageParams.getPageNo(), pageParams.getPageSize());
    // 查询数据内容获得结果
    Page<CourseBase> pageResult = courseBaseMapper.selectPage(page, queryWrapper);
    // 获取数据列表
    List<CourseBase> list = pageResult.getRecords();
    // 获取数据总数
    long total = pageResult.getTotal();
    // 构建结果集
    PageResult<CourseBase> courseBasePageResult = new PageResult<>(list, total, pageParams.getPageNo(), pageParams.getPageSize());

    return courseBasePageResult;

}
```























