# 内容管理模块-课程分类、新增课程、修改课程、课程计划

[TOC]



# 一、课程分类

点击“添加课程”，之后随便选一个“课程形式”

![image-20231107222138556](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231107222138556.png)

然后有一个“课程分类”，我们下面就要实现课程分类，这个地方缺少一个课程分类的下拉框

![image-20231107222227362](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231107222227362.png)

## 1.1 课程分类表

典型的树形分类结构

![image-20231107224534473](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231107224534473.png)

![image-20231109211534507](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109211534507.png)

```java
@Data
@TableName("course_category")
public class CourseCategory implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    private String id;

    /**
     * 分类名称
     */
    private String name;

    /**
     * 分类标签默认和名称一样
     */
    private String label;

    /**
     * 父结点id（第一级的父节点是0，自关联字段id）
     */
    private String parentid;

    /**
     * 是否显示
     */
    private Integer isShow;

    /**
     * 排序字段
     */
    private Integer orderby;

    /**
     * 是否叶子
     */
    private Integer isLeaf;


}
```



**创建一个Dto，方便之后向前端响应课程分类表数据**

```java
@Data
public class CourseCategoryTreeDto extends CourseCategory implements Serializable {

    //Serializable:在网络传输需要序列化的时候，需要实现Serializable接口
    private static final long serialVersionUID = 2950235607890841126L;

    //下级节点
    List<CourseCategoryTreeDto> childrenTreeNodes;
    
}
```

**展示出来是下面这种格式**

```java
{
"id" : "1-2",
"isLeaf" : null,
"isShow" : null,
"label" : "移动开发",
"name" : "移动开发",
"orderby" : 2,
"parentid" : "1",
"childrenTreeNodes" : [
               {
                  "childrenTreeNodes" : null,
                  "id" : "1-2-1",
                  "isLeaf" : null,
                  "isShow" : null,
                  "label" : "微信开发",
                  "name" : "微信开发",
                  "orderby" : 1,
                  "parentid" : "1-2"
               }
 }

```



## 1.2 查询树形结构

### 1.2.1 表自连接

**假如说数据层级比较固定，而且数据层级比较少，可以使用表自连接的方式**

```sql
select one.id one_id, one.label one_label, 
       two.id two_id,two.label two_label,
			 three.id three_id,three.label three_label
from course_category one -- one是表的别名，表示一级分类

inner join course_category two -- two是表的别名，表示二级分类
      on two.parentid = one.id -- 子节点的parentid是父节点的id
inner join course_category three
       on  three.parentid = two.id
```

**查询结果**

![image-20231109211920604](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109211920604.png)

### 1.2.2 SQL递归

**灵活的方式实现树形表的查询，比如使用MYSQL递归实现，使用with语法**

> 递归时MySQL8之后才有的

**递归语法**

```mysql
WITH [RECURSIVE]
        cte_name [(col_name [, col_name] ...)] AS (subquery)
        [, cte_name [(col_name [, col_name] ...)] AS (subquery)] 

```

**cte_name :公共表达式的名称,可以理解为表名,用来表示as后面跟着的子查询**

**col_name :公共表达式包含的列名,可以写也可以不写**

> 有一个关键字RECURSIVE，就是递归的含义
>
> cte_name相当于表的一个别名
>
> (col_name [, col_name] ...)]是表中的哪些字段
>
> 

**示例代码**

```sql
--  t1J就是一个虚拟表
with RECURSIVE t1  AS
(
-- 这个t1表的初始数据就是1
  SELECT 1 as n
	
-- 将下面查询出的数据结果集放入t1虚拟表中
  UNION ALL
	
-- 下面是递归查询的内容
  SELECT n + 1 FROM t1 WHERE n < 5
)

-- 查询最终结果
SELECT * FROM t1;
```

![image-20231109213712866](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109213712866.png)



**下面查询树形结果的SQL,向下递归**

> 向下递归：先拿一级节点，拿到一级节点后找二级节点，拿到二级节点后找三级节点........

```sql
with RECURSIVE t1  AS(
--  初始数据，就认为是根节点
  select * from course_category as p where id = '1'

--  每递归一次就把数据放入t1
union all

--  由树根找叶子
select t2.* 
from course_category as t2
INNER JOIN t1
      ON t2.parentid =  t1.id 
 
--  当我们拿到id为1的结点，递归后就可以拿到1-1等子结点的结果集
--  当我们拿到id为1-1等结点后，递归后就可以拿到1-1-1等子结点结果集
--  .......
)

select * from t1
```

![image-20231109220313874](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109220313874.png)



**向上递归**

> 向上递归：拿到最下一级的节点后找次下及节点.....
>
> 由子节点找父节点

```sql
with RECURSIVE t1  AS(
--  初始数据，就认为是根节点
  select * from course_category as p where id = '1-1-1'

--  每递归一次就把数据放入t1
union all

--  由树根找叶子
select t2.* 
from course_category as t2
INNER JOIN t1
      ON t2.id =  t1.parentid 
 
--  当我们拿到id为1的结点，递归后就可以拿到1-1等子结点的结果集
--  当我们拿到id为1-1等结点后，递归后就可以拿到1-1-1等子结点结果集
--  .......
)

select * from t1
```

![image-20231109221252895](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109221252895.png)



> mysql为了避免无限递归默认递归次数为1000，可以通过设置cte_max_recursion_depth参数增加递归深度，还可以通过max_execution_time限制执行时间，超过此时间也会终止递归操作。
>
> mysql递归相当于在存储过程中执行若干次sql语句，java程序仅与数据库建立一次链接执行递归操作，所以只要控制好递归深度，控制好数据量性能就没有问题。



## 1.3 Mapper

```java
//使用递归查询分类
public List<CourseCategoryTreeDto> selectTreeNodes(@Param("id") String id);
```



```xml
    <!--查询课程分类-->
    <select id="selectTreeNodes" resultType="com.xuecheng.content.model.dto.CourseCategoryTreeDto">
        with RECURSIVE t1 AS (
            select *
            from course_category as p
            where id = #{id}
            union all
            select t2.*
            from course_category as t2
                     INNER JOIN t1
                                ON t2.parentid = t1.id
        )

        select *
        from t1
        order by t1.id, t1.orderby

    </select>
```

我们现在从数据库中查到的数据是下列这个模样

![image-20231109225811919](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109225811919.png)

**代码中查询出来的数据如下所示**

![image-20231109225958818](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109225958818.png)

## 1.4 Service

要将Mapper层返回的数据进行进一步的处理。

将根节点id=1舍弃不要，因为在业务上没什么需要了

我们要将子节点放入到父节点的childrenTreeNodes集合里面。比如将1-1-x的节点放入到1-1节点的childrenTreeNodes集合里面

```java
@Slf4j
@Service
public class CourseCategoryServiceImpl implements CourseCategoryService {

    @Autowired
    private CourseCategoryMapper courseCategoryMapper;

    @Override
    public List<CourseCategoryTreeDto> queryTreeNodes(String id) {
        //TODO 数据库递归查询出课程分类信息
        List<CourseCategoryTreeDto> courseCategoryTreeDtos = courseCategoryMapper.selectTreeNodes(id);


        //TODO 找到每个节点的子节点，最终封装成List<CourseCategoryTreeDto>
        //将list转map,以备使用,排除根节点
        Map<String, CourseCategoryTreeDto> mapTemp = courseCategoryTreeDtos.stream()
                //!id.equals(item.getId()) 含义就是排除根节点
                .filter(item -> !id.equals(item.getId()))
                .collect(
                        //转Map是需要一个key，一个value的
                        //第一个key是代表元素的意思，key -> key.getId()是拿到key元素的id，然后充当Map的key
                        //value表示对象的本身，所以不需要任何的处理
                        //(key1, key2) -> key2 表示当key重复的时候（键相同），以后来的key为主
                        Collectors.toMap(key -> key.getId(), value -> value, (key1, key2) -> key2)
                );

        //最终返回的list
        List<CourseCategoryTreeDto> categoryTreeDtos = new ArrayList<>();

        //依次遍历每个元素,排除根节点
        //courseCategoryTreeDtos是从数据库查询出来的全部的数据
        courseCategoryTreeDtos.stream().filter(item -> !id.equals(item.getId())).forEach(item -> {
            if (item.getParentid().equals(id)) {
                //紧挨根节点下的节点
                categoryTreeDtos.add(item);
            }
            //找到当前节点的父节点
            CourseCategoryTreeDto courseCategoryTreeDto = mapTemp.get(item.getParentid());
            if (courseCategoryTreeDto != null) {
                if (courseCategoryTreeDto.getChildrenTreeNodes() == null) {
                    courseCategoryTreeDto.setChildrenTreeNodes(new ArrayList<CourseCategoryTreeDto>());
                }
                //下边开始往ChildrenTreeNodes属性中放子节点
                courseCategoryTreeDto.getChildrenTreeNodes().add(item);
            }
        });
        return categoryTreeDtos;
    }

}
```

## 1.5 Controller

```java
/**
 * 课程分类相关接口
 */
@Slf4j
@RestController
public class CourseCategoryController {


    @Autowired
    private CourseCategoryService courseCategoryService;

    @GetMapping("/course-category/tree-nodes")
    public List<CourseCategoryTreeDto> queryTreeNodes() {
        return courseCategoryService.queryTreeNodes("1");
    }

}
```



## 1.6 效果图

![image-20231109233240245](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231109233240245.png)





# 二、新增课程

![image-20231107222056328](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20231107222056328.png)



# 三、修改课程







# 四、课程计划

