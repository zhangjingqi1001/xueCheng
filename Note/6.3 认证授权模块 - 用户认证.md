# 认证授权模块 - 用户认证

[TOC]

# 一、用户认证

> 依然是xuecheng-auth模块



**实现如下图所示的流程**：

我们要实现的其实就是下图中圈出来的部分，**最重要的就是统一认证入口**

![image-20240125233912169](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240125233912169.png)



**认证所需要的用户信息存储在用户中心数据库，现在需要将认证服务连接数据库查询用户信息**



## 1.1 连接数据库认证

### 1.1.0 用户表 xc_user

![image-20240126000533169](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240126000533169.png)

![image-20240126000554935](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240126000554935.png)

**实体类**

```java
@Data
@TableName("xc_user")
public class XcUser implements Serializable {

    private static final long serialVersionUID = 1L;

    private String id;

    private String username;

    private String password;

    private String salt;

    private String name;
    
    private String nickname;
    
    private String wxUnionid;
    
    private String companyId;
    /**
     * 头像
     */
    private String userpic;

    private String utype;

    private LocalDateTime birthday;

    private String sex;

    private String email;

    private String cellphone;

    private String qq;

    /**
     * 用户状态
     */
    private String status;

    private LocalDateTime createTime;

    private LocalDateTime updateTime;


}
```

### 1.1.1 分析

一般认证就是用户输入账号和密码，判断用户是否存在和判断密码是否正确，有时候可能还会需要验证码

**登录界面**

> http://www.51xuecheng.cn/sign.html

![image-20240125233537887](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240125233537887.png)



**认证用户的流程如下图所示**

1. 一个请求过来之后首先到我们SpringSecurity框架认证管理器AuthenticationManager
2. DaoAuthenticationProvider就是用来查询数据库的，会通过loadUserByUsername()获取用户信息，并封装成一个UserDetails类型的对象

> loadUserByUsername方法是UserDetailsService接口的方法
>
> **简单来说：用户提交账号和密码由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息**

![image-20240125234652894](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240125234652894.png)

* **UserDetailsService接口内容**

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
}
```

我们只要实现UserDetailsService 接口查询数据库得到用户信息返回UserDetails 类型的用户信息即可,框架自己调用loadUserByUsername()方法拿到用户信息之后执行逻辑如下图所示

![image-20240125235612727](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240125235612727.png)

* **查询DaoAuthenticationProvider的源代码如下**：

![img](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/clip_image002.gif)



* **UserDetails用户信息接口**

```java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```



### 1.1.2 安全管理配置 WebSecurityConfig

**下面的代码是在内存中配置的用户信息，将其删掉，因为我们要从数据库中查询**

```java
//配置用户信息服务
@Bean
public UserDetailsService userDetailsService() {
    //这里配置用户信息,这里暂时使用这种方式将用户存储在内存中
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withUsername("zhangsan").password("123").authorities("p1").build());
    manager.createUser(User.withUsername("lisi").password("456").authorities("p2").build());
    return manager;
}
```

**配置密码加密方式**

```java
    @Bean
    public PasswordEncoder passwordEncoder() {
        //密码为明文方式
        //return NoOpPasswordEncoder.getInstance();
        
        //密码为加密之后
        return new BCryptPasswordEncoder();
    }
```

**其他配置**

```java
//配置安全拦截机制
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
            .authorizeRequests()
            .antMatchers("/r/**").authenticated()//访问/r开始的请求需要认证通过
            .anyRequest().permitAll()//其它请求全部放行
            .and()
            .formLogin().successForwardUrl("/login-success");//登录成功跳转到/login-success
}

@Bean
public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
}
```

### 1.1.3 自定义UserDetailsService 

> 下面这篇文章和此处获取UserDetails对象的方式不同，可能是因为包不同的原因
>
> [SpringSecurity - 基于数据库认证与授权](https://blog.csdn.net/weixin_51351637/article/details/134063693)
>
> 在目前1.1.3所使用的security包中无法使用下面的代码
>
> ```java
> SecurityUser securityUser = new SecurityUser(sysUser);
> ```

```java
@Component
public class UserServiceImpl implements UserDetailsService {

    //注入，将来查询对象
    @Autowired
    XcUserMapper xcUserMapper;

    /**
     * @param s 其实就是输入的username（账号）
     */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 1.根据username账号查询数据库
        // 因为账号是不可能重复的，直接selectOne即可
        LambdaQueryWrapper<XcUser> lqw = new LambdaQueryWrapper<>();
        lqw.eq(XcUser::getUsername, s);
        XcUser xcUser = xcUserMapper.selectOne(lqw);

        // 2.查询不到用户，返回null即可，SpringSecurity框架会自动抛出异常“用户不存在”
        if (xcUser == null) {
            return null;
        }
        // 3.如果查到了用户并查询到正确的密码，将用户信息封装成UserDetails类型数据返回，SpringSecurity框架会比对密码是否正确，我们不用比对密码
        String password = xcUser.getPassword();

        UserDetails userDetails = User.withUsername(s)
                //用户密码
                .password(password)
                //用户权限,暂时先不写
                .authorities("").build();
        return userDetails;
    }
}
```



### 1.1.4 授权服务器配置 AuthorizationServer

将客户端秘钥改成密文，不再是明文“XcWebApp”

```java
    //客户端详情服务
    @Override
    public void configure(ClientDetailsServiceConfigurer clients)
            throws Exception {
        clients.inMemory()// 使用in-memory存储
                .withClient("XcWebApp")// client_id
//                .secret("XcWebApp")//客户端密钥
                .secret(new BCryptPasswordEncoder().encode("XcWebApp"))//客户端密钥
                .resourceIds("xuecheng-plus")//资源列表
                .authorizedGrantTypes("authorization_code", "password", "client_credentials", "implicit", "refresh_token")// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials
                .scopes("all")// 允许的授权范围
                .autoApprove(false)//false跳转到授权页面
                //客户端接收授权码的重定向地址
                .redirectUris("http://www.51xuecheng.cn")
        ;
    }
```





## 1.2 扩展用户身份信息

用户表中存储了用户的账号、手机号、email，昵称、qq等信息，UserDetails接口只返回了username、密码等信息

> 如果只返回一个“user_name”字段是不够用的

![image-20240126003835774](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240126003835774.png)

**SpringSecurity中UserDetails接口如下所示**

```java
public interface UserDetails extends Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
```



**如何扩展Spring Security的用户身份信息呢**？

在认证阶段DaoAuthenticationProvider会调用UserDetailService查询用户的信息，这里是可以获取到齐全的用户信息的。

由于JWT令牌中用户身份信息来源于UserDetails，UserDetails中仅定义了username为用户的身份信息，

这里有**两个思路**：

**第一**是可以扩展UserDetails，使之包括更多的自定义属性

**第二**也可以扩展username的内容 ，比如存入json数据内容作为username的内容。

相比较而言，方案二比较简单还不用破坏UserDetails的结构，我们**采用方案二**



### 1.2.1 修改 UserServiceImpl

```java
    /**
     * @param s 其实就是输入的username（账号）
     */
    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        // 1.根据username账号查询数据库
        // 因为账号是不可能重复的，直接selectOne即可
        LambdaQueryWrapper<XcUser> lqw = new LambdaQueryWrapper<>();
        lqw.eq(XcUser::getUsername, s);
        XcUser xcUser = xcUserMapper.selectOne(lqw);

        // 2.查询不到用户，返回null即可，SpringSecurity框架会自动抛出异常“用户不存在”
        if (xcUser == null) {
            return null;
        }
        // 3.如果查到了用户并查询到正确的密码，将用户信息封装成UserDetails类型数据返回，SpringSecurity框架会比对密码是否正确，我们不用比对密码
        String password = xcUser.getPassword();

        //用户权限,如果不加报Cannot pass a null GrantedAuthority collection
        String[] authorities = {"p1"};

        xcUser.setPassword(""); // 为了安全考虑，专JSON前吧密码做空
        String userString = JSON.toJSONString(xcUser);
        UserDetails userDetails = User.withUsername(userString)
                //用户密码
                .password(password)
                //用户权限,暂时先不写
                .authorities(authorities).build();
        return userDetails;
    }
```





### 1.2.2 用户身份信息

user_name存储了用户信息的json格式，在资源服务中就可以取出该json格式的内容转为用户对象去使用

![image-20240126004715370](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240126004715370.png)





## 1.3  工具类获取用户身份

**下边编写一个工具类在各个微服务中去使用，获取当前登录用户的对象**

**比如我们在content模块要获取用户身份，那我们就把工具类放在content模块下**

```java
/**
 * @description 获取当前用户身份工具类
 */
@Slf4j
public class SecurityUtil {

    public static XcUser getUser() {
        try {
            // getContext() 获取上下文对象,getAuthentication()拿到认证信息,getPrincipal()拿到身份信息
            Object principalObj = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
            if (principalObj instanceof String) {
                //取出用户身份信息
                String principal = principalObj.toString();
                //将json转成对象
                XcUser user = JSON.parseObject(principal, XcUser.class);
                return user;
            }
        } catch (Exception e) {
            log.error("获取当前登录用户身份出错:{}", e.getMessage());
            e.printStackTrace();
        }

        return null;
    }


    // 内部类 因为XcUser是在auth服务中，并不在content服务中，所以在这里我们使用了一个内部类
    // 其实是完全一样的
    @Data
    public static class XcUser implements Serializable {

        private static final long serialVersionUID = 1L;

        private String id;

        private String username;

        private String password;

        private String salt;

        private String name;

        private String nickname;

        private String wxUnionid;

        private String companyId;
        /**
         * 头像
         */
        private String userpic;

        private String utype;

        private LocalDateTime birthday;

        private String sex;

        private String email;

        private String cellphone;

        private String qq;

        /**
         * 用户状态
         */
        private String status;

        private LocalDateTime createTime;

        private LocalDateTime updateTime;
    }
}
```



**使用**

```java
@ApiOperation("修改课程接口")
@PutMapping("/course")
public CourseBaseInfoDto getCourseBaseById(@RequestBody EditCourseDto editCourseDto) {
    // getContext() 获取上下文对象,getAuthentication()拿到认证信息,getPrincipal()拿到身份信息
    //SecurityContextHolder.getContext().getAuthentication().getPrincipal();
    SecurityUtil.XcUser user = SecurityUtil.getUser();
    System.out.println(user.getUsername());
    //机构id先写死，后面授权认证的时候后会改过来
    Long companyId = 1232141425L;
    return courseBaseInfoService.updateCourseBase(companyId, editCourseDto);
}
```



## 1.4 统一认证入口



