# 媒资管理模块 - 视频处理

[TOC]

**我们将会按照下面的两张图来处理我们的视频**

![image-20240109212746395](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240109212746395.png)

![image-20240109212426323](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240109212426323.png)

# 一、查询待处理任务

## 1.1 需求分析

查询待处理任务只处理未提交及处理失败的任务，任务处理失败后进行重试，最多重试3次

> 第一步，将上传成功的视频放入到待处理任务表中
>
> 第二步，是调度中心将将待处理任务表中的任务分配到各个执行器
>
> 第三步，执行器开始执行任务进行转码操作，转码完成后会更新数据库里面的处理结果

**待处理任务表media_process**

> 历史任务表与待处理任务表的结构相同

我们可以通过file_id字段去media_file表中查询对应的file_id字段，就可以找到对应的文件

通过status字段我们可以实现任务的幂等性，并且当任务完成后status字段的值为2，然后再把这条记录给删除掉，将此删掉的记录再记录到media_process_history表中

![image-20240109213127763](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240109213127763.png)



## 1.2 添加待处理任务

> 会对下面文章的代码进行改造
>
> [4.3 媒资管理模块 - Minio系统上传图片与视频](https://blog.csdn.net/weixin_51351637/article/details/135188811?spm=1001.2014.3001.5501)

**什么时候添加待处理任务**？

我们需要在media-service模块中找到上传视频的代码，在等到上传视频成功、合并视频分块成功后向数据库media_process表中添加待处理任务

我们在代码中其实可以在视频合并成功并且将视频文件信息入库之后再添加待处理任务，并且确保添加待处理任务要在事物之中

> 我们要确保视频上传成功后待处理任务一定要添加成功

**根据MIME Type去判断是否是avi视频，下边列出部分MIME Type**

> 并不是所有的文件都会添加到待处理任务表中，而是只有文件是avi的视频才会添加到待处理任务表中

![image-20240109215448681](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240109215448681.png)

avi视频的MIME Type是video/x-msvideo

**将文件信息添加到文件表的同时，也要将avi文件添加到待处理任务表中**

```java
/**
 * @param companyId           机构id
 * @param fileMd5             文件md5值
 * @param uploadFileParamsDto 上传文件的信息
 * @param bucket              桶
 * @param objectName          对象名称
 * @return com.xuecheng.media.model.po.MediaFiles
 * @description 将文件信息添加到文件表
 */

@Transactional
public MediaFiles addMediaFilesToDb(Long companyId, String fileMd5, UploadFileParamsDto uploadFileParamsDto, String bucket, String objectName) {
    //根据文件MD5值向数据库查找文件信息
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5);
    if (mediaFiles == null) {
        mediaFiles = new MediaFiles();
        BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles);
        mediaFiles.setId(fileMd5);//文件信息的主键是文件的MD5值
        mediaFiles.setCompanyId(companyId);//机构ID
        mediaFiles.setBucket(bucket);//桶
        mediaFiles.setFilePath(objectName);//对象名
        mediaFiles.setFileId(fileMd5);//file_id字段
        mediaFiles.setUrl("/" + bucket + "/" + objectName);//url
        mediaFiles.setCreateDate(LocalDateTime.now());//上传时间
        mediaFiles.setStatus("1");//状态 1正常 0不展示
        mediaFiles.setAuditStatus("002003");//审核状态 002003审核通过
        int insert = mediaFilesMapper.insert(mediaFiles);
        if (insert <= 0) {
            log.debug("向数据库保存文件失败bucket:{},objectName:{}", bucket, objectName);
            return null;
        }
    }
    //TODO 记录待处理任务
    this.addWaitingTask(mediaFiles);
    return mediaFiles;
}
```



**添加待处理任务**

```java
/**
 * 添加待处理任务
 *
 * @param mediaFiles 媒资文件信息，是media_files表的实体类
 */
private void addWaitingTask(MediaFiles mediaFiles) {
    //必须要判断一下，通过mimeType判断文件类型一定是avi视频文件才会添加到待处理任务中，其他的问题并不会
    //文件名称
    String filename = mediaFiles.getFilename();
    //通过文件的扩展名获取mimeType
    String mimeType = getMimeType(filename.substring(filename.lastIndexOf(".")));
    if (mimeType.equals("video/x-msvideo")) {
        //说明文件是avi文件，需要写入待处理任务表
        MediaProcess mediaProcess = new MediaProcess();
        BeanUtils.copyProperties(mediaFiles,mediaProcess);
        mediaProcess.setStatus("1");//未处理
        mediaProcess.setFailCount(0);//失败次数默认为0
        mediaProcess.setUrl(null);
        //向mediaProcess插入记录
        mediaProcessMapper.insert(mediaProcess);
    }
}
```

**根据扩展名获取mimeType**

```java
/**
 * 根据扩展名获取mimeType
 *
 * @param extension 扩展名
 */
private String getMimeType(String extension) {
    if (extension == null) {
        //目的是防止空指针异常
        extension = "";
    }
    ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(extension);
    //通用mimeType，字节流
    String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;
    if (extensionMatch != null) {
        mimeType = extensionMatch.getMimeType();
    }
    return mimeType;
}
```



**测试**

上传几个avi视频，观察待处理任务表是否存在记录，记录是否完成





## 1.3 查询待处理任务



### 1.3.1 MediaProcessMapper

```java
/**
 * 媒资信息 Mapper 接口
 */
public interface MediaFilesMapper extends BaseMapper<MediaFiles> {
    /**
     * @param shardTotal 分片总数
     * @param shardIndex 分片序号
     * @param count      任务数
     * @return java.util.List<com.xuecheng.media.model.po.MediaProcess>
     * @description 根据分片参数获取待处理任务
     * @author Mr.M
     * @date 2022/9/14 8:54
     */
    @Select("select * from media_process t where t.id % #{shardTotal} = #{shardIndex} and (t.status = '1' or t.status = '3') and t.fail_count < 3 limit #{count}")
    List<MediaProcess> selectListByShardIndex(@Param("shardTotal") int shardTotal, @Param("shardIndex") int shardIndex, @Param("count") int count);

}
```





### 1.3.2 MediaFileProcessServiceImpl

此类专门来进行事物处理

```java
@Autowired
MediaFilesMapper mediaFilesMapper;

@Autowired
MediaProcessMapper mediaProcessMapper;


@Override
public List<MediaProcess> getMediaProcessList(int shardIndex, int shardTotal, int count) {
    List<MediaProcess> mediaProcesses = mediaProcessMapper.selectListByShardIndex(shardTotal, shardIndex, count);
    return mediaProcesses;
}
```



# 二、分布式锁开启任务

我们的执行器就可以开始执行任务了

在下面这篇文章中3.1技术方案保证任务不重复执行其实是保证不了的

[媒资管理模块 - 分布式任务处理介绍、视频处理技术方案](https://blog.csdn.net/weixin_51351637/article/details/135490171?spm=1001.2014.3001.5501)

**假如说现在有四个执行器**

0和1号执行器由于网络原因断掉了，任务调度中心也检测不到0和1号

此时2和3号执行器变成了新0和新1号执行器，

新0和新1号执行器就会重新去数据库查询待处理任务并进行处理，此时很有可能新0和新1号执行器执行的任务和旧0和旧1执行器执行的任务重复

**此时我们就要使用锁来控制**

## 2.1 分布式锁

为了避免多线程去争抢同一个任务可以使用synchronized同步锁去解决，如下代码：

```java
synchronized(锁对象){
   执行任务...
}
```

synchronized只能保证同一个虚拟机中多个线程去争抢锁。

![image-20240109231024022](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240109231024022.png)

如果是多个执行器分布式部署，并不能保证同一个视频只有一个执行器去处理。

现在要实现分布式环境下所有虚拟机中的线程去同步执行就需要让多个虚拟机去共用一个锁，虚拟机可以分布式部署，锁也可以分布式部署，如下图：

![image-20240109231053167](https://picture-typora-zhangjingqi.oss-cn-beijing.aliyuncs.com/image-20240109231053167.png)

虚拟机都去抢占同一个锁，锁是一个单独的程序提供加锁、解锁服务。

**该锁已不属于某个虚拟机，而是分布式部署，由多个虚拟机所共享，这种锁叫分布式锁**。

**实现分布式锁的方案有很多，常用的如下**：

1、**基于数据库实现分布锁**

利用数据库主键唯一性的特点，或利用数据库唯一索引、行级锁的特点，多个线程同时去更新相同的记录，谁更新成功谁就抢到锁。

2、基于redis实现锁

redis提供了分布式锁的实现方案，比如：SETNX、set nx、redisson等。

拿SETNX举例说明，SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。

3、使用zookeeper实现

zookeeper是一个分布式协调服务，主要解决分布式程序之间的同步的问题。zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁。



## 2.2 开启任务

**基于数据库方式实现分布锁，开始执行任务将任务执行状态更新为4表示任务执行中**

**使用乐观锁的方式实现更新操作**

```sql
update media_process m set m.status='4' where (m.status='1' or m.status='3') and m.fail_count<3 and m.id=?
```

下面这句SQL是不可以的，因为任何时候都能够更新成功

```sql
update media_process m set m.status='4' where  m.id=?
```

> **什么是乐观锁、悲观锁**？
>
> synchronized是一种悲观锁，在执行被synchronized包裹的代码时需要首先获取锁，没有拿到锁则无法执行，是总悲观的认为别的线程会去抢，所以要悲观锁。
>
> 乐观锁的思想是它不认为会有线程去争抢，尽管去执行，如果没有执行成功就再去重试。



### 2.2.1 MediaProcessMapper

```java
    /**
     * 开启一个任务
     * status状态,1:未处理，2：处理成功  3处理失败
     * fail_count:失败次数
     * @param id 任务id
     * @return 更新记录数
     */
    @Update("update media_process m set m.status='4' where (m.status='1' or m.status='3') and m.fail_count<3 and m.id=#{id}")
    int startTask(@Param("id") long id);

```





### 2.2.2 MediaFileProcessServiceImpl

```java
/**
 *  开启一个任务
 * @param id 任务id
 * @return true开启任务成功，false开启任务失败
 */
@Override
public boolean startTask(long id) {
    int result = mediaProcessMapper.startTask(id);
    return result<=0?false:true;
}
```



# 三、保存任务处理结果

最终任务执行完毕后我们要把任务的处理结果在media_process表中体现一下

任务处理完成需要更新任务处理结果，任务执行成功更新视频的URL、及任务处理结果，将待处理任务记录删除，同时向历史任务表添加记录。

## 3.1 MediaFileProcessService

```java
/**
 * 更新media_process待完成任务表
 * status状态,1:未处理，2：处理成功  3处理失败
 *
 * @description 保存任务结果
 * @param taskId  任务id，也是media_process表的主键
 * @param status 任务状态
 * @param fileId  文件id
 * @param url url
 * @param errorMsg 错误信息
 * @return void
 */
@Override
public void saveProcessFinishStatus(Long taskId, String status, String fileId, String url, String errorMsg) {
    //查出任务，如果不存在则直接返回
    MediaProcess mediaProcess = mediaProcessMapper.selectById(taskId);
    if(mediaProcess == null){
        return ;
    }
    //TODO 如果任务执行处理失败，更新任务处理结果
    LambdaQueryWrapper<MediaProcess> queryWrapperById = new LambdaQueryWrapper<MediaProcess>().eq(MediaProcess::getId, taskId);
    //处理失败
    if(status.equals("3")){
        MediaProcess mediaProcess_u = new MediaProcess();
        mediaProcess_u.setStatus("3"); //任务状态
        mediaProcess_u.setErrormsg(errorMsg); //失败的信息
        mediaProcess_u.setFailCount(mediaProcess.getFailCount()+1); //失败次数
        mediaProcessMapper.update(mediaProcess_u,queryWrapperById);//执行更新操作
        log.debug("更新任务处理状态为失败，任务信息:{}",mediaProcess_u);
        return ;
    }
    //TODO 如果任务处理成功，更新media_files表中文件的url，因为我们修改了文件格式，那url也需要改一下
    MediaFiles mediaFiles = mediaFilesMapper.selectById(fileId);
    if(mediaFiles!=null){
        //更新媒资文件中的访问url（之前视频的后缀是avi，但是现在是mp4，所以url路径改变了）
        mediaFiles.setUrl(url);
        mediaFilesMapper.updateById(mediaFiles);
    }
    //TODO 处理成功，更新media_process表url和状态
    mediaProcess.setUrl(url);
    mediaProcess.setStatus("2");
    mediaProcess.setFinishDate(LocalDateTime.now());
    mediaProcessMapper.updateById(mediaProcess);

    //TODO 添加到历史记录
    MediaProcessHistory mediaProcessHistory = new MediaProcessHistory();
    BeanUtils.copyProperties(mediaProcess, mediaProcessHistory);
    mediaProcessHistoryMapper.insert(mediaProcessHistory);

    //TODO 最后删除mediaProcess
    mediaProcessMapper.deleteById(mediaProcess.getId());

}
```



# 四、处理视频任务



## 

